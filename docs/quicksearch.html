<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"global.html":{"id":"global.html","title":"Global","body":" Documentation Classes Semaphore Global waitwaitCallback Global Methods wait(stop, arg, delay) Wraps the waitCallback function into a Promise. Parameters: Name Type Default Description stop number 1 the number of delay iterations. This is would be in seconds if delay is 1000 millis. arg Object null an object that should be returned by the callback when the wait is complete. delay number 1000 the number of millis to pause per stop. Returns: a Javascript promise object Type Promise waitCallback(stop, cb, arg, delay) Uses the timeout function to create a pause in a function without stopping the event loop. The default without any parameters is a 1 second pause. When the timeout ends a callback is executed and it receives the arg parameter to be used in the callback. Parameters: Name Type Default Description stop number 1 the number of delay iterations. This is would be in seconds if delay is 1000 millis. cb function null a callback function that is executed when the timeout is complete. arg Object null an object that should be returned by the callback when the wait is complete. delay number 1000 the number of millis to pause per stop. × Search results Close Documentation generated by JSDoc 3.4.3 on March 3rd 2017, 7:27:59 pm using the DocStrap template. "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" Documentation Classes Semaphore Global waitwaitCallback Classes Classes Semaphore × Search results Close Documentation generated by JSDoc 3.4.3 on March 3rd 2017, 7:27:59 pm using the DocStrap template. "},"index.html":{"id":"index.html","title":"Index","body":" Documentation Classes Semaphore Global waitwaitCallback util.wait Javascript pause/wait functions This library contains two functions and a class: wait - JavaScript function that returns a Promise and can be used in a thenable chain to delay for N iterations of S seconds. waitCallback - JavaScript function that uses a callback after N iterations of S seconds. Semaphore - A simple JavaScript semaphore counter object. Creates a completion barrier with a counter. The two functions are used to create a delay in processing without stopping the event loop. It does this by using a wrapped Timeout call. The functions rely on the processing of a Promise or a callback to do this. The class implements a simple semaphore counter. An instance of Semaphore is created. Before the wait() promise is called the semaphore is incremented and/or decremented. While the semaphore counter is &gt; 0 a wait state will occur. During processing the semaphore is decremented as a process that uses the semaphore is finishd with it. When the counter is &lt;= 0 then the wait() state will end and the semaphore promise will be resolved. InstallationTo install as a global package: $ npm install --global util.waitTo install as an application dependency: $ npm install --save util.waitTo build the app and run all tests: $ npm run allUsagewaitCallback(3, (val: any) =&gt; { // continuation after 3 second wait. The val is passed to the callback // after time has expired. In this example the string 'stuff' is // passed. }, 'stuff');This wait function will pause for N sections and use a callback function on completion. The example shows that at the end of 3 seconds it is called to complete the wait. const wait = require('util.wait').wait; wait(3, 'something') .then((val: any) =&gt; { // continuation after 3 second wait the val is the value passed // to then after time has expired. In this example it would // pass the string 'something' }) .catch((err: string) =&gt; { console.error(err); });This version calls wait with a Promise object returned that can be chained together using then (thenable). This is just a wrapper on around the first function to make it thenable. The use case for this is within test cases that use other promises where a delay is beneficial to wait some amount of time for async operations to finish in the test (such as testing a timed interval and its results). const Semaphore = require('util.wait').Semaphore; let semaphore = new Semaphore(10); function f1() { console.log(`Starting F1: ${new Date()}`); semaphore.increment(); assert(semaphore.counter === 1); // Arbitrary delay to show that the semaphore is waiting waitCallback(2, () =&gt; { semaphore.decrement(); console.log(`Done with f1 (2 seconds): ${new Date()}`); }); } function f2() { console.log(`Starting F2: ${new Date()}`); semaphore.increment(); assert(semaphore.counter === 2); // Arbitrary delay to show that the semaphore is waiting waitCallback(5, () =&gt; { semaphore.decrement(); console.log(`Done with f2 (5 seconds): ${new Date()}`); }); } f1(); f2(); semaphore.wait() .then(() =&gt; { assert(semaphore.counter === 0); debug(`Finished: ${semaphore.toString()}`); }) .catch((err: string) =&gt; { assert(false, err); });This example creates a semaphore with a 10 second timeout. It has two functions f1 and f2. Both functions run for an arbitrary amount of time in a delay loop. They increment and decrement the semaphore. After the two functions are started the semaphore starts its wait() state promise. When the delay functions within f1 and f2 complete they each decrement the semaphore. When the semaphore counter reaches 0 the promise will be resolved. If the timeout occurs, then the catch within the promise will reject with an error. × Search results Close Documentation generated by JSDoc 3.4.3 on March 3rd 2017, 7:27:59 pm using the DocStrap template. "},"Semaphore.html":{"id":"Semaphore.html","title":"Class: Semaphore","body":" Documentation Classes Semaphore Global waitwaitCallback Class: Semaphore Semaphore Creates an instance of the Semaphore class new Semaphore(timeout, ticks) This creates a simple semaphore counter instance. Each async function will increment the semaphore as they are created. As they finish their operation within the same process will decrement it. When the wait() is started it will look at the counter to see if there are processes still waiting to finish (counter &gt; 0). It will then perform a delay loop and check for semaphore completion (count === 0). It will continue this check until the counter reaches 0 or the timeout occurs. Parameters: Name Type Default Description timeout number the number of seconds that this semaphore will check for completion. If the semaphore has not completed at the end of this delay an Error will returned to the wait callback. ticks number 200 the number of times the semaphore will be checked. the timeout is divided by this number to determine how often the semaphore will be checked during the timeout. This will prevent blowing up the call stack. Methods decrement() Decrements the internal value of the semaphore counter Returns: the current value of the counter. increment() Increments the internal value of the semaphore counter Returns: the current value of the counter. reset() Resets the internal state of the semaphore instance. Generally used once a semaphore is complete and needs to be reused. toString() Returns: a string representation of the semaphore instance wait(self) Activated at some point in a process when one wants to wait for all semaphores to complete processing. This call does not block the event loop. This uses a Promise object to make the call async. Parameters: Name Type Description self Semaphore a reference to the Semaphore instance Returns: a JavaScript promise object. waitCallback(cb, arg, self) Activated at some point in a process when one wants to wait for all semaphores to complete processing. This uses a callback function to signal completion instead of a Promise. Parameters: Name Type Default Description cb function a callback function that is executed when the semaphore is complete. arg Object null an argument that can be passed to the callback self Semaphore a reference to the Semaphore instance × Search results Close Documentation generated by JSDoc 3.4.3 on March 3rd 2017, 7:27:59 pm using the DocStrap template. "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
